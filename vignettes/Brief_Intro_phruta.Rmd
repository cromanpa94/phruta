---
title: "Introduction to the `phruta` R package"
author: Cristian RomÃ¡n-Palacios
date: '`r paste("First created on 2021-07-30. Updated on", Sys.Date())`'
vignette: >
  %\VignetteIndexEntry{Brief intro to the `phruta` R package}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
output:
#  pdf_document:
#    highlight: null
#    number_sections: yes
  knitr:::html_vignette:
    toc: true
    fig_caption: yes
---

```{r include = FALSE}
knitr::opts_chunk$set(eval = FALSE, warning = FALSE, message = FALSE)
```


# Table of Contents

1.  [What is `phruta`](#intro)
2.  [Functions in `phruta`](#paragraph0)
3.  [From taxonomic names to time-calibrated phylogenies](#paragraph1)
4.  [Installing RAxML](#paragraph2)
5.  [Installing PATHd-8 and treePL](#paragraph3)

## What is `phruta` <a name="intro"></a>

The `phruta` R package is designed to simplify the basic phylogenetic pipeline and allow scientists from different backgrounds to assemble their own phylogenies. All code in `phruta` is run within the same program (`R`) and data from intermediate steps are saved locally in independent folders. Furthermore, all code is run within the same environment which increases the reproducibility of your analysis. `phruta` looks for potentially (phylogenetically) relevant gene regions for a given set of taxa, retrieves gene sequences, could combine newly downloaded and local gene sequences, performs sequence alignments, phylogenetic inference, and tree dating. `phruta` is also able to perform basic phylogenetic inference under `RAxML` on the resulting sequence alignments. The current release allows users to conduct tree dating based on secondary calibrations. `phruta` is essentially a wrapper for alternative `R` packages and software.

## Functions in `phruta`

The current release of `phruta` includes a set of eight major functions. All eight functions form a pipeline within `phruta` to output a time-calibrated phylogeny. However, users interested in using their own files at any stage can run each function independently.

Note that all the functions for which their primary output are sequences (aligned or unaligned) are listed under `sq.*`. All the files that output phylogenies (time-calibrated or not) are listed under `tree.*`.

-   First, the distribution of gene sampled for a given organism or set of taxa can be explored using the `acc.gene.sampling` function. This function will return a table that summarizes either the distribution of genes sampled for the search term in general or specifically across species.

-   Second, given a list of target organisms, users can retrieve a list of accession numbers that are relevant to their search using `acc.table.retrieve`. Instead of directly downloading sequences from genbank (see `sq.retrieve.direct` below), retrieving accession numbers allow users to have more control over the sequences that are being used in the analyses. Note that users can also curate the content of the dataset obtained using `sq.retrieve.direct`.

-   Third, users should download gene sequences. Sequences can be download using the `sq.retrieve.indirect` from the accession numbers retrieved before using the `acc.table.retrieve` function. This is the preferred option within `pruta`. Additionally, users can directly download gene sequences using the `sq.retrieve.direct` function. Both `sq.retrieve.indirect` and `sq.retrieve.direct` functions save gene sequences in `fasta` files that will be located in a new directory named `0.Sequences`.

-   Fourth, `sq.add` allows users to include local sequences to those retrieved from genbank in the previous step. This function saves all the resulting `fasta` files in two directories, combined sequences in `0.Sequences` and local sequences in `0.AdditionalSequences` (originally downloaded sequences are moved to `0.0.OriginalDownloaded` at this step). Note that `sq.add` is optional.

-   Fifth, the `sq.curate` function filters out unreliable sequences based on information listed in genbank (e.g. PREDICTED) and on taxonomic information provided by the user. Specifically, this function retrieves taxonomic information from the Global Biodiversity Information Facility (GBIF) database's taxonomic backbone (see alternatives in the advanced vignette to `pruta`). If a given species belongs to a non-target group, this species is dropped from the analyses. This function automatically corrects taxonomy and renames sequences.

-   Sixth, `sq.aln` performs multiple sequence alignment on `fasta` files. Currently, `phruta` uses the [`DECIPHER` R package](http://www2.decipher.codes/), here. This package allows for adjusting sequence orientation and masking (removing ambiguous sites).

The final two functions in `phruta` focus on tree inference and dating. These two functions depend on external software that needs to be installed (**and tested**) before running. Please make sure both `RAxML` and `PATHd-8` or `treePL` are installed and can be called within `R` using the `system()` function. Note that you can choose between `PATHd-8` and `treePL`. More details on how to install `RAxML` are provided [below](#paragraph2). Similarly, we provide details on how to install `PATHd-8` and `treePL` [below](#paragraph3).

-Seventh, the `tree.raxml` function allows users to perform tree inference under `RAxML` for sequences in a given folder. This is a wraper to `ips::raxml` and each of the arguments can be customized. The current release of `phruta` can manage both partitioned and unpartitioned analyses. Starting and constrained trees are allowed.

-Eith, `tree.dating` enables users to perform time-calibrations of a given phylogeny using `geiger::congruify.phylo`. `phruta` includes a basic set of comprehensively sampled, time-calibrated phylogenies that are used to extract secondary calibrations for the target phylogeny. Note that sampling in those phylogenies can be examined using `data(SW.phruta)`. Please make sure you have at least **two** groups in common with each of the phylogenies. Similarly, users can choose to run either `PATHd-8` or `treePL`.

## Intro tutorial: Clade names to sequence alignments <a name="paragraph1"></a>

Let's create a phylogeny for a few mammal clades. Assume that we need to build a tree for the following three genera: *Felis, Vulpes*, and *Phoca*. All three genera are within Carnivora. Both *Felis* and *Vulpes* are classified in different superfamilies within Fissipedia and *Phoca* is part of another suborder, Pinnipedia. We're going to root our tree with another mammal species, a Chinese Pangolin ( *Manis pentadactyla*). Users can select additional target species, however, for simplicity, we will run the analyses using three genera in the ingroup and a single outgroup species.

So far, we have decided the taxonomic make of our analyses. However, we also need to determine the characteristics of the molecular dataset that we would like to assemble. Fortunately, mammals are extensively studied and a comprehensive list of potential gene regions to be analized is already available. For instance, we could use same gene regions as in [Upham et al (2009)](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.3000494#sec030). Nevertheless, for this tutorial, we will simply try to find the gene regions are well sampled for the target taxa. I believe that figuring out the best sampled gene regions in genbank, instead of providing names, is potentially more valuable when working with poorly studied groups. Before we move on, please make sure that you you have [set a working directory for this project](http://rfunction.com/archives/1001) as all the files will be saved to the current working directory.

Now, let's look for the gene regions that are sampled for our target taxa. For this, we will use the `gene.sampling.retrieve` function in `pruta`. The resulting `data.frame`, named `gs.seqs` in this example, will contain the list of full names for genes sampled in genbank for the target taxa.

```{r }
start_time <- Sys.time()
library(phruta)
gs.seqs <- gene.sampling.retrieve(organism = c("Felis", "Vulpes", "Phoca", "Manis_pentadactyla"), speciesSampling=TRUE)
head(gs.seqs)
```

For the search terms, `phruta` was able to retrieve the names for multiple gene regions . The `gene.sampling.retrieve` provides an estimate of the number of species in genbank (matching the taxonomic criteria of the search term) that have sequences for a given gene region. However, this estimate is only as good as the annotations for genes deposited in genbank. 

From here, we will generate a preliminary table summarizing accession numbers for the combination of taxa and gene regions that we're interested in sampling. In fact, not all these accession numbers are expected to be in the final (curated) molecular dataset. Using the `acc.table.retrieve` function, we will assemble a species-level summary of accession numbers (hence the `speciesLevel = TRUE` argument). For simplicity, this tutorial will focus on sampling gene regions that are sampled in >30% of the species (`targetGenes` data.frame).

```{r }
targetGenes <- gs.seqs[gs.seqs$PercentOfSampledSpecies>30,]

acc.table <- acc.table.retrieve(
            clades  = c('Felis', 'Vulpes', 'Phoca'),
            species = 'Manis_pentadactyla' ,
            genes   = targetGenes$Gene,
            speciesLevel = TRUE
          )
head(acc.table)
```

The `acc.table` object is a `data.frame` that is later on going to be used for downloading locally the relevant gene sequences. Feel free to review this dataset, make changes, add new species, samples, etc. The integrity of this dataset is critical for the next steps so please take your time and review it carefully. Let's just make some minor changes to our dataset:

```{r }
acc.table$Species <- sub("P.", "Phoca ", acc.table$Species, fixed = T)
acc.table$Species <- sub("F.", "Felis ", acc.table$Species, fixed = T)
acc.table$Species <- sub("V.", "Vulpes ", acc.table$Species, fixed = T)
acc.table$Species <- sub("mitochondrial", "", acc.table$Species)
```

Now, since we're going to retrieve sequences from genbank, we will use the `sq.retrieve.indirect` function in `phruta`. I'm going to stop here to mention that there are two versions of `sq.retrieve.*` in the `R` package. The one that we're using in this tutorial, `sq.retrieve.indirect`, retrieves sequences "indirectly" because it necessarily follows the intermediate step of generating a table summarizing accession numbers (see the `acc.table.retrieve` function above). I present the information in this vignette using `sq.retrieve.indirect` instead of `sq.retrieve.direct` because the first function is way more flexible and allows for correcting issues *prior* to download any sequence. For instance, you can add new sequences, species, populations to the resulting data.frame from `acc.table.retrieve`. Additionally, you could even manually assemble your own dataset of accession numbers to be retrieved using `sq.retrieve.indirect`. Instead, `sq.retrieve.direct` does its best to directly (i.e. without potential input from the user) retrieve sequences for a target set of taxa and set of gene regions. In short, you should be able to catch errors using `sq.retrieve.indirect` but mistakes will be harder to spot and fix if you're using `sq.retrieve.direct`.

Now, we still need to retrieve the sequences from the accessions table `acc.table`. The `sq.retrieve.indirect` function will write all the resulting fasta files into the newly created folder `0.Sequences` located in our working directory.

```{r }
sq.retrieve.indirect(acc.table)
```

Next, we're going to make sure that we include only sequences that are reliable and from species that we are interested in analyzing. We're going to use the `sq.curate` function for this. We will provide a list of taxonomic criteria to filter out incorrect sequences (`filterTaxonomicCriteria` argument), which in this case can be just the genera that we're interested in analyzing. Note that the outgroup's name should also be included in the list. If the taxonomic information for a sequence retrieved from genbank does not match with any of these strings, this species will be dropped. You will have to specify whether sampling is for animals or plants (`kingdom` argument). Finally, you might have already noticed that we have "cytochrome oxidase subunit 1" and "cytochrome c oxidase subunit I" as different gene regions. We can combine the sequences in these two files into a single file names `COI` that will be used in the next steps. Specifically, to merge gene files, you will have to provide a named list to the `mergeGeneFiles` argument of the `sq.curate` function. This named list (`tb.merged` in our tutorial) will have a length that equals the number of final files that

```{r }
tb.merged <- list('COI'=c("cytochrome oxidase subunit 1", "cytochrome c oxidase subunit I"))
sq.curate(filterTaxonomicCriteria='Felis|Vulpes|Phoca|Manis',
          mergeGeneFiles=tb.merged,
          kingdom='animals', 
          folder='0.Sequences',
          removeOutliers = FALSE)
```

Running this line will create the new folder `1.CuratedSequences` that contains (1) the curated sequences with original names, (2) curated sequences with species-level names (`renamed_*` prefix), (3) an accession table (`0.AccessionTable.csv`), and (4) a summary of taxonomic information for all the species sampled in the files (`1.Taxonomy.csv`). We'll use the `renamed_*` and `1.Taxonomy.csv` files in the next steps.

Next, we'll align the sequences that we just curated. For this, we just use `sq.aln` with default parameters.

```{r }
sq.aln(folder='1.CuratedSequences', FilePatterns = "renamed")
```

The resulting multiple sequence alignments will be saved to the `2.Alignments` folder. In this folder, we will have two types of files: (1) raw alignments (same file names as in `1.CuratedSequences`) and (2) alignments with ambiguous sites removed (`Masked_*` prefix). 

We can use the resulting alignments to infer phylogenies. We cover these steps within `phruta` in the next vignette: "Phylogenetics with the `phruta` R package".


```{r}
library(ape)
files <- list.files("2.Alignments", pattern="Masked_",full.names = T)
sampleALNs <- lapply(files, read.FASTA); names(sampleALNs) <- files
par(mfrow=c(round(length(sampleALNs)/2),2))
for(i in seq_along(sampleALNs)){
image(sampleALNs[[i]], main=files[i])
}
end_time <- Sys.time()
```

