taxonomy.retrieve(species_names=species_names, database='itis')
}
library(pbapply)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
Taxonomy_species
# Remove PREDICTED species
if (length(grep("PREDICTED", AccDat$Species)) > 0) {
dupDel <- AccDat[grep("PREDICTED", AccDat$Species), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[-grep("PREDICTED", AccDat$Species), ]
}
# Remove duplicated species
if (any(duplicated(AccDat[, c(3:4)]))) {
dupDel <- AccDat[duplicated(AccDat[, c(3:4)]), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[!duplicated(AccDat[, c(3:4)]), ]
}
Full_dataset <- cbind.data.frame(Taxonomy_species, species_names)
Full_dataset$originalSpeciesName <- Full_dataset$species_names
Full_dataset$species_names <- sub(" ", "_", Full_dataset$species)
Full_dataset <- na.omit(Full_dataset)
Full_dataset
"%nin%" <- Negate("%in%")
toDel <- AccDat[which(AccDat$Species %nin% Full_dataset$originalSpeciesName), 1]
# Remove any non-species species
if (length(toDel) > 0) {
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% toDel]
})
AccDat <- AccDat[!AccDat$OriginalNames %in% toDel, ]
}
Full_dataset <- Full_dataset[Full_dataset$originalSpeciesName %in% AccDat$Species, ]
WrongSpecies <- Full_dataset[!apply(Full_dataset, 1, function(x) any(grepl(filterTaxonomicCriteria, x))), ]
RightSpecies <- Full_dataset[apply(Full_dataset, 1, function(x) any(grepl(filterTaxonomicCriteria, x))), ]
if (nrow(WrongSpecies) > 0) {
seqsToDel <- AccDat[AccDat$Species %in% WrongSpecies, "OriginalNames"]
AccDat <- AccDat[!AccDat$Species %in% WrongSpecies, ]
curatedSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% seqsToDel]
})
names(curatedSeqs) <- names(fastaSeqs)
} else {
curatedSeqs <- fastaSeqs
}
## Rename incorrect synonyms
toRename <- Full_dataset[Full_dataset$originalSpeciesName != Full_dataset$species_names, ]
toRename
AccDat <- AccDat[AccDat$file %in% names(which(table(AccDat$file) > 1)), ]
Full_dataset <- Full_dataset[Full_dataset$originalSpeciesName %in% AccDat$Species, ]
newspp <- unlist(lapply(AccDat$Species, function(x) {
Full_dataset[Full_dataset$originalSpeciesName == x, "species_names"]
}))
AccDat$OldSpecies <- AccDat$Species
AccDat$Species <- newspp
row.names(AccDat) <- NULL
AccDat
Full_dataset
database='itis'
fastaSeqs <- lapply(list.files(folder, full.names = T), read.FASTA)
names(fastaSeqs) <- list.files(folder, full.names = F)
seqNames <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][c(2:3)], collapse = "_")))
seqAccN <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][1], collapse = "_")))
AccDat <- data.frame("OriginalNames" = unlist(lapply(fastaSeqs, names)), "AccN" = seqAccN, "Species" = seqNames)
AccDat$file <- rep(list.files(folder, full.names = F), unlist(lapply(fastaSeqs, length)))
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
Taxonomy_species
# Remove PREDICTED species
if (length(grep("PREDICTED", AccDat$Species)) > 0) {
dupDel <- AccDat[grep("PREDICTED", AccDat$Species), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[-grep("PREDICTED", AccDat$Species), ]
}
# Remove duplicated species
if (any(duplicated(AccDat[, c(3:4)]))) {
dupDel <- AccDat[duplicated(AccDat[, c(3:4)]), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[!duplicated(AccDat[, c(3:4)]), ]
}
Full_dataset <- cbind.data.frame(Taxonomy_species, species_names)
Full_dataset$originalSpeciesName <- Full_dataset$species_names
Full_dataset$species_names <- sub(" ", "_", Full_dataset$species)
species_names
db
database
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
taxo<-classification(species_names, db = database, rows = 1)
do.call(ranks, NA)
x=1
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}{  }
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}
matrix(nrow = 1, ncol = length(ranks))
matrix(nrow = 1, ncol = length(ranks)-1)
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
sma[,length(ranks)]
cbind(sma, species_names[,x])
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[,x])
species_names[,x]
cbind(sma, species_names[x])
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
taxo
taxo<-classification(species_names, db = database, rows = 1)
species_names
species_names=c("Felis_catus", "PREDICTED:_Vulpes",
"Phoca_largha", "PREDICTED:_Phoca" ,
"PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes")
species_names
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
species_names
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
fastaSeqs <- lapply(list.files(folder, full.names = T), read.FASTA)
names(fastaSeqs) <- list.files(folder, full.names = F)
seqNames <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][c(2:3)], collapse = "_")))
seqAccN <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][1], collapse = "_")))
AccDat <- data.frame("OriginalNames" = unlist(lapply(fastaSeqs, names)), "AccN" = seqAccN, "Species" = seqNames)
AccDat$file <- rep(list.files(folder, full.names = F), unlist(lapply(fastaSeqs, length)))
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
?classification
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
invisible(
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
)
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
setwd("~/MEGA/Packages/Macbook2/phruta")
?classification
pkgdown:::build_site_external()
pkgdown:::build_site_external()
pkgdown:::build_site_external()
pkgdown:::build_site_external()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(phruta)
