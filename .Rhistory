targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLevgroups[[x]] <- nextLev
}
names(nextLevgroups)<-additionalLevels
##Not working for nested lists!!
lapply(nextLevgroups, unlist)
unTa<-lapply(nextLevgroups, function(x) unlist(lapply(x,unlist)))
names(unTa[[1]]) <- names(firstLev)
groups<-unlist(unTa)
names(groups)<-gsub("^.*\\.","", names(groups) )
nextLev<-as.list(groups)
}
return(nextLev)
}
getListConstraints(taxonomy, byClades=T)
classification<-lapply(1:length(targetColumns)-1, function(x){
q<-unique(unlist(dataset[targetColumns[x+1]]))
na<-lapply(q, function(y){
dataset[which(dataset[,targetColumns[x+1]] == y )[1], targetColumns[x] ]
})
names(q)<-na
q2<- lapply(unique(names(q)), function(z){
q<-q[names(q) == z]
names(q)<-NULL
q
})
names(q2)<-unique(names(q))
q2
})
names(classification)<-targetColumns
firstLev<-lapply(classification[length(classification) ][[1]], function(x){
paste0('(',paste( unlist(x) , collapse = ','),')')
})
names(firstLev)<-names(classification[length(classification) ][[1]])
additionalLevels<-rev(names(classification))[-1]
nextLevgroups<-list()
for(x in 1:length(additionalLevels)){
nextLev <- if(x==1){firstLev}else{nextLev}
targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLevgroups[[x]] <- nextLev
}
names(nextLevgroups)<-additionalLevels
##Not working for nested lists!!
lapply(nextLevgroups, unlist)
unTa<-lapply(nextLevgroups, function(x) unlist(lapply(x,unlist)))
names(unTa[[1]]) <- names(firstLev)
groups<-unlist(unTa)
names(groups)<-gsub("^.*\\.","", names(groups) )
nextLev<-as.list(groups)
nextLev
#' Get a list of constraints given a taxonomic dataset
#' @description Internal used to generate tree constraints
#' @keywords internal
#' @export
getListConstraints<- function(dataset, byClades=F){
classification<-lapply(1:length(targetColumns)-1, function(x){
q<-unique(unlist(dataset[targetColumns[x+1]]))
na<-lapply(q, function(y){
dataset[which(dataset[,targetColumns[x+1]] == y )[1], targetColumns[x] ]
})
names(q)<-na
q2<- lapply(unique(names(q)), function(z){
q<-q[names(q) == z]
names(q)<-NULL
q
})
names(q2)<-unique(names(q))
q2
})
names(classification)<-targetColumns
##Combine all species per first level
firstLev<-lapply(classification[length(classification) ][[1]], function(x){
paste0('(',paste( unlist(x) , collapse = ','),')')
})
names(firstLev)<-names(classification[length(classification) ][[1]])
##Combine all families per superfamily
additionalLevels<-rev(names(classification))[-1]
if(byClades == F){
for(x in 1:length(additionalLevels)){
nextLev <- if(x==1){firstLev}else{nextLev}
targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLev
}
}else{
nextLevgroups<-list()
for(x in 1:length(additionalLevels)){
nextLev <- if(x==1){firstLev}else{nextLev}
targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLevgroups[[x]] <- nextLev
}
names(nextLevgroups)<-additionalLevels
unTa<-lapply(nextLevgroups, function(x) unlist(lapply(x,unlist)))
names(unTa[[1]]) <- names(firstLev)
groups<-unlist(unTa)
names(groups)<-gsub("^.*\\.","", names(groups) )
nextLev<-as.list(groups)
}
return(nextLev)
}
getListConstraints(taxonomy, byClades=T)
#' Get a list of constraints given a taxonomic dataset
#' @description Internal used to generate tree constraints
#' @keywords internal
#' @export
getListConstraints<- function(dataset, byClades=F){
classification<-lapply(1:length(targetColumns)-1, function(x){
q<-unique(unlist(dataset[targetColumns[x+1]]))
na<-lapply(q, function(y){
dataset[which(dataset[,targetColumns[x+1]] == y )[1], targetColumns[x] ]
})
names(q)<-na
q2<- lapply(unique(names(q)), function(z){
q<-q[names(q) == z]
names(q)<-NULL
q
})
names(q2)<-unique(names(q))
q2
})
names(classification)<-targetColumns
##Combine all species per first level
firstLev<-lapply(classification[length(classification) ][[1]], function(x){
paste0('(',paste( unlist(x) , collapse = ','),')')
})
names(firstLev)<-names(classification[length(classification) ][[1]])
##Combine all families per superfamily
additionalLevels<-rev(names(classification))[-1]
if(byClades == F){
for(x in 1:length(additionalLevels)){
nextLev <- if(x==1){firstLev}else{nextLev}
targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLev
}
}else{
nextLevgroups<-list()
for(x in 1:length(additionalLevels)){
nextLev <- if(x==1){firstLev}else{nextLev}
targetGroups<-classification[names(classification) == additionalLevels[x]][[1]]
if(x ==1){
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[i] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}else{
nextLevNested<-list()
for(i in 1:length(targetGroups)){
nextLevP<-nextLev[names(nextLev) == targetGroups[[i]] ]
nextLevNested[[i]]<- paste(nextLevP, collapse = ',')
}
names(nextLevNested)<-names(targetGroups)
nextLev<-nextLevNested
nextLev
}
nextLevgroups[[x]] <- nextLev
}
names(nextLevgroups)<-additionalLevels
unTa<-lapply(nextLevgroups, function(x) unlist(lapply(x,unlist)))
names(unTa[[1]]) <- names(firstLev)
groups<-unlist(unTa)
names(groups)<-gsub("^.*\\.","", names(groups) )
nextLev<-as.list(groups)
}
return(nextLev)
}
getListConstraints(taxonomy, byClades=T)
outgroup
clades<-list("ingroup"= getListConstraints(ingroup, byClades=F), "outgroup" = getListConstraints(outgroup, byClades=F))
clades
names(clades[i])
clades[[i]]
Topology
Topology="((ingroup), outgroup);"
Topology<- gsub(names(clades[i]),clades[[i]]  ,Topology)
Topology
clades
for(i in seq_along(clades)){
Topology<- gsub(names(clades[i]),clades[[i]]  ,Topology)
}
Topology
Topology
Topology='(Felis);'
Topology
strsplit(Topology, ',')
sub(';', '', Topology)
Topology<-sub('(', '', Topology, fixed = T)
Topology
Topology='(Felis);'
Topology<-sub(';', '', Topology, fixed = T)
Topology<-sub('(', '', Topology, fixed = T)
Topology<-sub(')', '', Topology, fixed = T)
Topology
Topology='(Felis, Phoca);'
Topology<-sub(';', '', Topology, fixed = T)
Topology<-sub('(', '', Topology, fixed = T)
Topology<-sub(')', '', Topology, fixed = T)
Topology
strsplit(Topology, ',')
strsplit(Topology, ',')[[1]]
TopologyOriginal<Topology
Topology='(Felis, Phoca);'
Topology1<-Topology
TopologyOriginal<-Topology
Topology<-sub(';', '', Topology, fixed = T)
Topology<-sub('(', '', Topology, fixed = T)
Topology<-sub(')', '', Topology, fixed = T)
clades<- strsplit(Topology, ',')[[1]]
clades
Topology<-sub(' ', '', Topology, fixed = T)
Topology
clades<- strsplit(Topology, ',')[[1]]
clades
for(i in seq_along(clades)){
TopologyOriginal<- gsub(names(clades[i]),clades[[i]]  ,TopologyOriginal)
}
clades
clades
cstByClade<-getListConstraints(taxonomy, byClades=T)
cstByClade
cstByClade[names(cstByClade) ==clades[i] ]
TopologyOriginal
for(i in seq_along(clades)){
TopologyOriginal<- gsub(clades[i], cstByClade[names(cstByClade) ==clades[i] ]  ,TopologyOriginal)
}
TopologyOriginal
Topology<-TopologyOriginal
unlink("3.2.Phylogeny.constraint", recursive = TRUE)
dir.create("3.2.Phylogeny.constraint")
write(Topology1, '3.2.Phylogeny.constraint/OriginalConstraints.cst.tre')
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
tree<-read.newick('3.2.Phylogeny.constraint/phruta.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.cst.tre')
Topology="((Felis), (Phoca));"
cstByClade<-getListConstraints(taxonomy, byClades=T)
Topology1<-Topology
TopologyOriginal<-Topology
Topology<-sub(';', '', Topology, fixed = T)
Topology<-sub('(', '', Topology, fixed = T)
Topology<-sub(')', '', Topology, fixed = T)
Topology<-sub(' ', '', Topology, fixed = T)
clades<- strsplit(Topology, ',')[[1]]
for(i in seq_along(clades)){
TopologyOriginal<- gsub(clades[i], cstByClade[names(cstByClade) ==clades[i] ]  ,TopologyOriginal)
}
Topology1
Topology
Topology="((Felis), (Phoca));"
cstByClade<-getListConstraints(taxonomy, byClades=T)
cstByClade
Topology1<-Topology
TopologyOriginal<-Topology
TopologyOriginal
Topology<-sub(';', '', Topology, fixed = T)
Topology<-sub('(', '', Topology, fixed = T)
Topology<-sub(')', '', Topology, fixed = T)
Topology<-sub(' ', '', Topology, fixed = T)
Topology
Topology<-sub(';', '', Topology, fixed = T)
Topology
Topology
Topology
Topology1
Topology=Topology1
TopologyOriginal<-Topology
TopologyOriginal
sub(';', '', Topology, fixed = T)
-sub('(', '', Topology, fixed = T)
sub('(', '', Topology, fixed = T)
gsub("\\s*\\([^\\)]+\\)","",Topology)
gsub("[()]", "", Topology)
Topology
Topology<-sub(';', '', Topology, fixed = T)
Topology<- gsub("[()]", "", Topology)
Topology
Topology<-sub(' ', '', Topology, fixed = T)
Topology
strsplit(Topology, ',')
clades<-strsplit(Topology, ',')[[1]]
for(i in seq_along(clades)){
TopologyOriginal<- gsub(clades[i], cstByClade[names(cstByClade) ==clades[i] ]  ,TopologyOriginal)
}
TopologyOriginal
Topology<-TopologyOriginal
unlink("3.2.Phylogeny.constraint", recursive = TRUE)
dir.create("3.2.Phylogeny.constraint")
write(Topology1, '3.2.Phylogeny.constraint/OriginalConstraints.cst.tre')
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
tree<-read.newick('3.2.Phylogeny.constraint/phruta.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.cst.tre')
clades
TopologyOriginal
TopologyOriginal
Topology
Topology1
Topology=Topology1
TopologyOriginal<-Topology
TopologyOriginal
Topology<-sub(';', '', Topology, fixed = T)
Topology<- gsub("[()]", "", Topology)
Topology<-sub(' ', '', Topology, fixed = T)
clades<-strsplit(Topology, ',')[[1]]
for(i in seq_along(clades)){
TopologyOriginal<- gsub(clades[i], cstByClade[names(cstByClade) ==clades[i] ]  ,TopologyOriginal)
}
TopologyOriginal
Topology<-TopologyOriginal
unlink("3.2.Phylogeny.constraint", recursive = TRUE)
dir.create("3.2.Phylogeny.constraint")
write(Topology1, '3.2.Phylogeny.constraint/OriginalConstraints.cst.tre')
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
tree<-read.newick('3.2.Phylogeny.constraint/phruta.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.cst.tre')
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
Topology
Topology
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
tree<-read.newick('3.2.Phylogeny.constraint/phruta.cst.tre')
tree
plot(tree)
tree<-read.tree('3.2.Phylogeny.constraint/phruta.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.cst.tre')
#' Tree inference under RAxML
#'
#' Performs tree inference under \code{"RAxML"} for aligned fasta sequences in
#' a given folder (default is \code{"2.Alignments"}).
#'
#' @param folder Name of the folder where the sequences to align are stored (character).
#' @param FilePatterns A string that is common to all the target files in the relevant folder (character). Note that
#'                     this argument can be set to \code{"NULL"} if no specific pattern wants to be analized.
#' @param raxml_exec Where to find \code{"RAxML"} or how to run it from the console? (string).
#' @param Bootstrap Number of bootstrap replicates (numeric).
#' @param outgroup A single string of comma-separated tip labels to be used as outgroup in
#'                 \code{"RAxML"} See \code{"RAxML"} documentation for more details (character).
#' @param partitioned Whether analyses should be partitioned by gene (Logical).
#' @param ... Arguments passed to \code{"ips::raxml"}.
#'
#' @importFrom phytools read.newick
#'
#' @return None
#'
#' @examples
#' \dontrun{
#' sq.retrieve(
#'   clades = c("Felis", "Vulpes", "Phoca"),
#'   species = "Manis_pentadactyla",
#'   genes = c("ADORA3")
#' )
#' sq.curate(
#'   filterTaxonomicCriteria = "Felis|Vulpes|Phoca|Manis",
#'   kingdom = "animals", folder = "0.Sequences"
#' )
#'
#'tree.constraint(taxonomy_folder="1.CuratedSequences",
#'                TaxonomyConstraints=T,
#'                targetColumns=c("kingdom","phylum","class","order","family","genus","species_names"),
#'                Topology="((ingroup), outgroup);",
#'                outgroup="Manis_pentadactyla")
#'tree.constraint(taxonomy_folder="1.CuratedSequences",
#'                TaxonomyConstraints=T,
#'                targetColumns=c("kingdom","phylum","class","order","family","genus","species_names"),
#'                Topology="((Felis), (Phoca));",
#'                outgroup="Manis_pentadactyla")
#' }
#' @export
tree.constraint <- function(taxonomy_folder="1.CuratedSequences",
TaxonomyConstraints=T,
targetColumns=c("kingdom","phylum","class","order","family","genus","species_names"),
Topology="((ingroup), outgroup);",
outgroup=NULL){
taxonomy<-read.csv(paste0(taxonomy_folder, '/1.Taxonomy.csv'))
if(Topology == "((ingroup), outgroup);"){
Topology1<-Topology
ingroup<-taxonomy[!taxonomy$species_names==outgroup,]
outgroup<-taxonomy[taxonomy$species_names==outgroup,]
clades<-list("ingroup"= getListConstraints(ingroup, byClades=F), "outgroup" = getListConstraints(outgroup, byClades=F))
for(i in seq_along(clades)){
Topology<- gsub(names(clades[i]),clades[[i]]  ,Topology)
}
}else{
cstByClade<-getListConstraints(taxonomy, byClades=T)
Topology1<-Topology
TopologyOriginal<-Topology
Topology<-sub(';', '', Topology, fixed = T)
Topology<- gsub("[()]", "", Topology)
Topology<-sub(' ', '', Topology, fixed = T)
clades<-strsplit(Topology, ',')[[1]]
for(i in seq_along(clades)){
TopologyOriginal<- gsub(clades[i], cstByClade[names(cstByClade) ==clades[i] ]  ,TopologyOriginal)
}
Topology<-TopologyOriginal
}
unlink("3.2.Phylogeny.constraint", recursive = TRUE)
dir.create("3.2.Phylogeny.constraint")
write(Topology1, '3.2.Phylogeny.constraint/OriginalConstraints.cst.tre')
write(Topology, '3.2.Phylogeny.constraint/phruta.cst.tre')
tree<-read.tree('3.2.Phylogeny.constraint/phruta.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.ape.cst.tre')
write.tree(tree, '3.2.Phylogeny.constraint/phruta.phytools.cst.tre')
}
tree.constraint(taxonomy_folder="1.CuratedSequences",
TaxonomyConstraints=T,
targetColumns=c("kingdom","phylum","class","order","family","genus","species_names"),
Topology="((Felis), (Phoca));",
outgroup="Manis_pentadactyla")
tree.constraint(taxonomy_folder="1.CuratedSequences",
TaxonomyConstraints=T,
targetColumns=c("kingdom","phylum","class","order","family","genus","species_names"),
Topology="((Felis), (Phoca));")
roxygen2::roxygenise()
setwd("~/MEGAsync/Packages/MacMini/phruta")
roxygen2::roxygenise()
roxygen2::roxygenise()
install.packages("spelling")
roxygen2::roxygenise()
