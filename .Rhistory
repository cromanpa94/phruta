}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
Taxonomy_species
# Remove PREDICTED species
if (length(grep("PREDICTED", AccDat$Species)) > 0) {
dupDel <- AccDat[grep("PREDICTED", AccDat$Species), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[-grep("PREDICTED", AccDat$Species), ]
}
# Remove duplicated species
if (any(duplicated(AccDat[, c(3:4)]))) {
dupDel <- AccDat[duplicated(AccDat[, c(3:4)]), "OriginalNames"]
fastaSeqs <- lapply(fastaSeqs, function(x) {
x[!names(x) %in% dupDel]
})
AccDat <- AccDat[!duplicated(AccDat[, c(3:4)]), ]
}
Full_dataset <- cbind.data.frame(Taxonomy_species, species_names)
Full_dataset$originalSpeciesName <- Full_dataset$species_names
Full_dataset$species_names <- sub(" ", "_", Full_dataset$species)
species_names
db
database
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
taxo<-classification(species_names, db = database, rows = 1)
do.call(ranks, NA)
x=1
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}{  }
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}
matrix(nrow = 1, ncol = length(ranks))
matrix(nrow = 1, ncol = length(ranks)-1)
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
sma[,length(ranks)]
cbind(sma, species_names[,x])
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[,x])
species_names[,x]
cbind(sma, species_names[x])
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
taxo
taxo<-classification(species_names, db = database, rows = 1)
species_names
species_names=c("Felis_catus", "PREDICTED:_Vulpes",
"Phoca_largha", "PREDICTED:_Phoca" ,
"PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes")
species_names
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
Taxonomy_species
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
species_names
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
fastaSeqs <- lapply(list.files(folder, full.names = T), read.FASTA)
names(fastaSeqs) <- list.files(folder, full.names = F)
seqNames <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][c(2:3)], collapse = "_")))
seqAccN <- unlist(lapply(unlist(lapply(fastaSeqs, names)), function(x) paste0(strsplit(x, " ")[[1]][1], collapse = "_")))
AccDat <- data.frame("OriginalNames" = unlist(lapply(fastaSeqs, names)), "AccN" = seqAccN, "Species" = seqNames)
AccDat$file <- rep(list.files(folder, full.names = F), unlist(lapply(fastaSeqs, length)))
species_names <- unique(AccDat$Species)
Taxonomy_species<-if(database=='gbif' ){
taxonomy.retrieve(species_names=species_names, database='gbif',
kingdom=kingdom)
}else{
taxonomy.retrieve(species_names=species_names, database='itis')
}
?classification
#' Curate sequences from genbank
#'
#' After downloading sequences from genbank, this function curates sequences based on taxonomic
#' information. Note that this function provides two summary datasets. First, the accession numbers.
#' Second, the taxonomic information for each species in the database. The taxonomy strictly follows
#' the gbif taxonomic backbone. The resulting files are saved to \code{"1.CuratedSequences"}. The
#' resulting files also have the most recent curated taxonomy following the gbif taxonomic backbone.
#'
#' @param species_names A vector of species names
#' @param database A name of a database with taxonomic information. 'gbif' only
#'                 works for animals and plants. Databases follows taxize::classification
#' @param kingdom Optional and only used when database='gbif'. Two possible options: "animals" or "plants."
#'
#' @import rgbif
#' @import taxize
#'
#' @return data.frame of taxonomic information for the target species (valid in the database)
#'
#' @examples
#' \dontrun{
#' taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
#'  "Phoca_largha", "PREDICTED:_Phoca" ,
#'  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
#'  database='gbif', kingdom='animals')
#' }
#' @export
taxonomy.retrieve<-function(species_names=NULL, database='gbif',
kingdom=NULL){
ranks <- c("kingdom", "phylum", "class", "order", "family", "genus", "species")
if(database != "gbif" ){
taxo<-classification(species_names, db = database, rows = 1)
invisible(
Taxonomy_species<-as.data.frame(do.call(rbind,lapply(seq_along(taxo), function(x){
if(!is.na(taxo[[x]])){
t(data.frame(taxo[[x]][taxo[[x]][,2] %in% ranks,1]))
}else{
sma<-matrix(nrow = 1, ncol = length(ranks)-1)
cbind(sma, species_names[x])
}
})))
)
row.names(Taxonomy_species)<-NULL
colnames(Taxonomy_species)<-ranks
Taxonomy_species$species <- sub(' ',"_",Taxonomy_species$species)
Taxonomy_species
}else{
##If animals and plants
gbifkey <- lapply(species_names, function(x) name_backbone(name = x, kingdom = kingdom))
keys <- pblapply(seq_along(gbifkey), function(x) {
if (as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "matchType")]) == "NONE") {
0
} else {
if (length(which(names(gbifkey[[x]]) == "acceptedUsageKey")) == 0) {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "usageKey")])
} else {
as.character(gbifkey[[x]][which(names(gbifkey[[x]]) == "acceptedUsageKey")])
}
}
})
gbif_taxonomy <- lapply(unlist(keys), function(x) as.data.frame(name_usage(key = x)$data))
Taxonomy_species <- lapply(seq_along(gbif_taxonomy), function(y) {
sub1 <- gbif_taxonomy[[y]]
cate <- t(data.frame(unlist(lapply(seq_along(ranks), function(x) {
nu <- which(colnames(sub1) == ranks[x])
if (length(nu) != 1) {
NA
} else {
sub1[, nu]
}
}))))
colnames(cate) <- ranks
row.names(cate) <- NULL
cate
})
Taxonomy_species <- do.call(rbind.data.frame, Taxonomy_species)
Taxonomy_species
}
}
setwd("~/MEGA/Packages/Macbook2/phruta")
?classification
pkgdown:::build_site_external()
pkgdown:::build_site_external()
pkgdown:::build_site_external()
pkgdown:::build_site_external()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(phruta)
setwd("~/Desktop")
setwd("~/Desktop/test")
folderAlignments = "2.Alignments"
FilePatterns = "Masked"
folderPartitionFinder = "2.1.PartitionFinderv1"
models = "all"
files_fullNames <- list.files(folderAlignments, FilePatterns, full.names = T)
files <- list.files(folderAlignments, FilePatterns)
seq <- lapply(lapply(files_fullNames, read.FASTA), as.matrix)
library(ape)
files_fullNames <- list.files(folderAlignments, FilePatterns, full.names = T)
files <- list.files(folderAlignments, FilePatterns)
seq <- lapply(lapply(files_fullNames, read.FASTA), as.matrix)
names(seq) <- files
concatenated <- do.call(cbind.DNAbin, c(seq,
fill.with.gaps = TRUE
))
partitions <- do.call(raxml.partitions, seq)
library(ips)
partitions <- do.call(raxml.partitions, seq)
seq
partitions <- do.call(raxml.partitions, seq)
raxml.partitions
partitions <- do.call(raxml.partitions, seq)
seq
pkgdown:::build_site_external()
setwd("~/MEGA/Packages/Macbook2/phruta")
pkgdown:::build_site_external()
roxygen2::roxygenise()
setwd("~/Desktop/test")
taxonomy_folder = "1.CuratedSequences"
targetColumns = c("kingdom", "phylum", "class", "order", "family", "genus", "species_names")
Topology = "((Felis), (Phoca));"
outgroup = NULL
taxonomy <- read.csv(paste0(taxonomy_folder, "/1.Taxonomy.csv"))
taxonomy
Topology
Topology == "((ingroup), outgroup);"
cstByClade <- getListConstraints(taxonomy, byClades = T)
cstByClade <- getListConstraints(taxonomy,targetColumns, byClades = T)
cstByClade
cstByClade <- invisible(getListConstraints(taxonomy,targetColumns, byClades = T))
Topology1 <- Topology
TopologyOriginal <- Topology
Topology <- sub(";", "", Topology, fixed = T)
Topology <- gsub("[()]", "", Topology)
Topology <- sub(" ", "", Topology, fixed = T)
clades <- strsplit(Topology, ",")[[1]]
for (i in seq_along(clades)) {
TopologyOriginal <- gsub(clades[i], cstByClade[names(cstByClade) == clades[i]], TopologyOriginal)
}
Topology <- TopologyOriginal
Topology
unlink("3.2.Phylogeny.constraint", recursive = TRUE)
dir.create("3.2.Phylogeny.constraint")
write(Topology1, "3.2.Phylogeny.constraint/OriginalConstraints.cst.tre")
write(Topology, "3.2.Phylogeny.constraint/phruta.cst.tre")
tree <- read.tree("3.2.Phylogeny.constraint/phruta.cst.tre")
write.tree(tree, "3.2.Phylogeny.constraint/phruta.ape.cst.tre")
roxygen2::roxygenise()
setwd("~/MEGA/Packages/Macbook2/phruta")
roxygen2::roxygenise()
pkgdown:::build_site_external()
setwd("~/Desktop/test")
tree.constraint(
taxonomy_folder = "1.CuratedSequences",
targetColumns = c("kingdom", "phylum", "class", "order", "family", "genus", "species_names"),
Topology = "((ingroup), outgroup);",
outgroup = "Manis_pentadactyla"
)
setwd("~/MEGA/Packages/Macbook2/phruta")
pkgdown:::build_site_external()
pkgdown:::build_site_external()
setwd("~/MEGA/Packages/Macbook2/phruta")
roxygen2::roxygenise()
install.packages("goodpractice")
lintr:::addin_lint_package()
